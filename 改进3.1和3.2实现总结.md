# 改进 3.1 和 3.2 实现总结

> 实现时间：2025-12-10  
> 基于：`LeverPlus_v3_RL_next_steps_2025_12_10.md`

---

## ✅ 3.1 把 RCE-only 明确固化成 v3 默认训练方式

### 修改内容

#### 1. 修改默认参数（`grpo_post_train.py` 第430-431行）

**修改前：**
```python
parser.add_argument("--rce_epochs", type=int, default=1, help="RCE预热epochs")
parser.add_argument("--grpo_epochs", type=int, default=3, help="GRPO训练epochs")
```

**修改后：**
```python
parser.add_argument("--rce_epochs", type=int, default=5, help="RCE预热epochs（推荐5，RCE-only baseline）")
parser.add_argument("--grpo_epochs", type=int, default=0, help="GRPO训练epochs（推荐0，即RCE-only模式；GRPO仅作为可选实验功能）")
```

#### 2. 添加保护逻辑（`grpo_post_train.py` 第383-395行）

**新增代码：**
```python
# ========== 阶段3：GRPO训练（可选）==========
if self.grpo_epochs <= 0:
    print("\n" + "="*100)
    print("⚠️  GRPO epochs == 0，仅进行 RCE 预热，不执行 GRPO。")
    print("="*100)
    print("✓ RCE-only baseline 训练完成，当前模型即为最终模型。")
    print("="*100)
    print("\n" + "="*100)
    print("✓ GRPO Post-Training 完成！")
    print("="*100)
    return  # 直接结束，当前模型即为 RCE-only baseline
```

### 效果

- ✅ **默认配置**：`--rce_epochs 5 --grpo_epochs 0`（RCE-only baseline）
- ✅ **避免误操作**：如果 `grpo_epochs=0`，会明确提示并直接结束，不会误运行 GRPO
- ✅ **保护现有成果**：避免不小心覆盖已经很好的 `rce_epoch5.pt` 模型

---

## ✅ 3.2 SFT checkpoint 加载时增加一致性检查

### 修改内容

#### 1. `generate_rl_data.py` 的 `load_sft_model` 函数（第88-110行）

**修改前：**
```python
model.load_state_dict(state_dict, strict=False)
model.to(device)
model.eval()
```

**修改后：**
```python
missing, unexpected = model.load_state_dict(state_dict, strict=False)

# 检查缺失的参数
if missing:
    print(f"[警告] 加载 checkpoint 时有 {len(missing)} 个参数缺失，例如：")
    for k in list(missing)[:10]:
        print(f"  - missing: {k}")
    if len(missing) > 10:
        print(f"  ... 还有 {len(missing) - 10} 个参数缺失")

# 检查多余的参数
if unexpected:
    print(f"[警告] 有 {len(unexpected)} 个多余参数，例如：")
    for k in list(unexpected)[:10]:
        print(f"  - unexpected: {k}")
    if len(unexpected) > 10:
        print(f"  ... 还有 {len(unexpected) - 10} 个多余参数")

# 如果缺失的关键参数太多，直接 raise
if len(missing) > 1000:
    raise RuntimeError(
        f"Checkpoint 与当前模型结构差异过大（缺失 {len(missing)} 个参数），请检查模型配置。"
    )

model.to(device)
model.eval()
```

#### 2. `grpo_post_train.py` 的 `train()` 方法（第333-367行）

**修改前：**
```python
if "model_state_dict" in ckpt:
    self.model.load_state_dict(ckpt["model_state_dict"], strict=False)
elif "state_dict" in ckpt:
    state_dict = {k.replace("model.", ""): v for k, v in ckpt["state_dict"].items()}
    self.model.load_state_dict(state_dict, strict=False)
else:
    self.model.load_state_dict(ckpt, strict=False)
```

**修改后：**
```python
# 根据checkpoint格式选择state_dict
if "model_state_dict" in ckpt:
    state_dict = ckpt["model_state_dict"]
elif "state_dict" in ckpt:
    # PyTorch Lightning格式
    state_dict = {k.replace("model.", ""): v for k, v in ckpt["state_dict"].items()}
else:
    state_dict = ckpt

# 加载并检查参数一致性
missing, unexpected = self.model.load_state_dict(state_dict, strict=False)

# 检查缺失的参数
if missing:
    print(f"[警告] 加载 checkpoint 时有 {len(missing)} 个参数缺失，例如：")
    for k in list(missing)[:10]:
        print(f"  - missing: {k}")
    if len(missing) > 10:
        print(f"  ... 还有 {len(missing) - 10} 个参数缺失")

# 检查多余的参数
if unexpected:
    print(f"[警告] 有 {len(unexpected)} 个多余参数，例如：")
    for k in list(unexpected)[:10]:
        print(f"  - unexpected: {k}")
    if len(unexpected) > 10:
        print(f"  ... 还有 {len(unexpected) - 10} 个多余参数")

# 如果缺失的关键参数太多，直接 raise
if len(missing) > 1000:
    raise RuntimeError(
        f"Checkpoint 与当前模型结构差异过大（缺失 {len(missing)} 个参数），请检查模型配置。"
    )
```

#### 3. `grpo_post_train.py` 主函数中的 v2 checkpoint 加载（第709行）

**修改前：**
```python
model.load_state_dict(filtered_state_dict, strict=False)
```

**修改后：**
```python
missing, unexpected = model.load_state_dict(filtered_state_dict, strict=False)

# 检查缺失的参数
if missing:
    print(f"[警告] 加载 v2 checkpoint 时有 {len(missing)} 个参数缺失，例如：")
    for k in list(missing)[:10]:
        print(f"  - missing: {k}")
    if len(missing) > 10:
        print(f"  ... 还有 {len(missing) - 10} 个参数缺失")

# 检查多余的参数
if unexpected:
    print(f"[警告] 有 {len(unexpected)} 个多余参数，例如：")
    for k in list(unexpected)[:10]:
        print(f"  - unexpected: {k}")
    if len(unexpected) > 10:
        print(f"  ... 还有 {len(unexpected) - 10} 个多余参数")

# 如果缺失的关键参数太多，直接 raise
if len(missing) > 1000:
    raise RuntimeError(
        f"v2 Checkpoint 与当前 v3 模型结构差异过大（缺失 {len(missing)} 个参数），请检查模型配置。"
    )
```

### 效果

- ✅ **早期发现问题**：在训练开始前就能发现 checkpoint 和模型结构不匹配
- ✅ **明确的错误信息**：显示缺失/多余的参数列表，便于调试
- ✅ **防止静默错误**：如果参数差异过大（>1000），直接 raise 错误，避免用错误的模型训练

---

## 测试建议

### 1. 测试 3.1（RCE-only 默认配置）

```bash
# 测试默认参数（应该自动使用 RCE-only 模式）
python -m lever_lm.workflows.grpo_post_train \
    --beam_data ./results/okvqa/generated_data/rl_data_RandSampler_Qwen2_5-VL-3B-Instruct.json \
    --query_emb ./results/okvqa/cache/query_embeddings.pt \
    --cand_emb ./results/okvqa/cache/candidate_embeddings.pt \
    --output_dir ./results/okvqa/model_cpk/v3_test \
    --device cuda:7

# 应该看到：
# ⚠️  GRPO epochs == 0，仅进行 RCE 预热，不执行 GRPO。
# ✓ RCE-only baseline 训练完成，当前模型即为最终模型。
```

### 2. 测试 3.2（Checkpoint 检查）

```bash
# 测试加载 checkpoint 时的检查
python -m lever_lm.models.v3.generate_rl_data \
    --sft_ckpt ./results/okvqa/model_cpk/v2/Qwen2_5_VL_3B_Instruct_RandSampler_*.ckpt \
    --beam_data ./results/okvqa/generated_data/vqa-okvqa-*.json \
    --output_path ./test_rl_data.json \
    --query_emb ./results/okvqa/cache/query_embeddings.pt \
    --cand_emb ./results/okvqa/cache/candidate_embeddings.pt \
    --device cuda:7

# 应该看到 checkpoint 加载时的参数检查信息
```

---

## 修改的文件

1. ✅ `lever_lm/workflows/grpo_post_train.py`
   - 修改默认参数（第430-431行）
   - 添加 RCE-only 保护逻辑（第383-395行）
   - 添加 checkpoint 加载检查（第333-367行，第709行）

2. ✅ `lever_lm/models/v3/generate_rl_data.py`
   - 添加 checkpoint 加载检查（第88-110行）

---

## 下一步

- ✅ **已完成**：3.1 和 3.2
- ⏭️ **可选**：3.3（Reward 质量标记）- 在下次生成 RL 数据时加上
- ⏭️ **可选**：3.4（rce_use_raw_reward 开关）- 等需要对比实验时再加

---

**修改完成时间：** 2025-12-10

